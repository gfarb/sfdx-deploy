"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateService = void 0;
const tslib_1 = require("tslib");
const fs = require("fs");
const path = require("path");
const yeoman = require("yeoman-environment");
const i18n_1 = require("../i18n");
const utils_1 = require("../utils");
const types_1 = require("../utils/types");
const gitRepoUtils_1 = require("./gitRepoUtils");
/**
 * Template Service
 */
class TemplateService {
    constructor(cwd = process.cwd()) {
        this.adapter = new utils_1.ForceGeneratorAdapter();
        // @ts-ignore the adaptor doesn't fully implement yeoman's adaptor yet
        this.env = yeoman.createEnv(undefined, { cwd }, this.adapter);
    }
    /**
     * Get an instance of TemplateService
     * @param cwd cwd of current yeoman environment. CLI: don't need to set explicitly. VS Code: it's typically the root workspace path
     */
    static getInstance(cwd) {
        if (!TemplateService.instance) {
            TemplateService.instance = new TemplateService(cwd);
        }
        else if (cwd) {
            TemplateService.instance.cwd = cwd;
        }
        return TemplateService.instance;
    }
    /**
     * Getting cwd of current yeoman environment
     */
    get cwd() {
        return this.env.cwd;
    }
    /**
     * Setting cwd of current yeoman environment
     * In VS Code, it's typically the root workspace path
     */
    set cwd(cwd) {
        this.env.cwd = cwd;
    }
    /**
     * Look up package version of @salesforce/templates package to supply a default API version
     */
    static getDefaultApiVersion() {
        const packageJsonPath = path.join('..', '..', 'package.json');
        const versionTrimmed = require(packageJsonPath).version.trim();
        return `${versionTrimmed.split('.')[0]}.0`;
    }
    /**
     * Create using templates
     * @param templateType template type
     * @param templateOptions template options
     * @param customTemplatesRootPathOrGitRepo custom templates root path or git repo. If not specified, use built-in templates
     */
    create(templateType, templateOptions, customTemplatesRootPathOrGitRepo) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.setCustomTemplatesRootPathOrGitRepo(customTemplatesRootPathOrGitRepo);
            if (customTemplatesRootPathOrGitRepo) {
                // In VS Code, if creating using a custom template, we need to reset the yeoman environment
                this.resetEnv();
            }
            const generatorClass = types_1.TemplateType[templateType].toString().charAt(0).toLowerCase() +
                types_1.TemplateType[templateType].toString().slice(1) +
                'Generator';
            const generatorNamespace = `@salesforce/${generatorClass}`;
            let generator = this.env.get(generatorNamespace);
            if (!generator) {
                generator = (yield Promise.resolve().then(() => require(`../generators/${generatorClass}`))).default;
                const generatorPackagePath = path.join(__dirname, '..', '..');
                this.env.registerStub(generator, generatorNamespace, generatorPackagePath);
            }
            this.adapter.log.clear();
            return new Promise((resolve, reject) => {
                this.env
                    .run(generatorNamespace, templateOptions)
                    .then(() => {
                    const outputDir = path.resolve(this.cwd, templateOptions.outputdir);
                    const created = this.adapter.log.getCleanOutput();
                    const rawOutput = i18n_1.nls.localize('RawOutput', [outputDir, this.adapter.log.getOutput()]);
                    const result = {
                        outputDir,
                        created,
                        rawOutput,
                    };
                    resolve(result);
                })
                    .catch((err) => {
                    reject(err);
                });
            });
        });
    }
    resetEnv() {
        const cwd = this.env.cwd;
        // @ts-ignore
        this.env = yeoman.createEnv(undefined, { cwd }, this.adapter);
    }
    /**
     * Set custom templates root path or git repo.
     * Throws an error if local path doesn't exist or cannot reach git repo.
     * @param customTemplatesRootPathOrGitRepo custom templates root path or git repo
     * @param forceLoadingRemoteRepo by default do not reload remote repo if the repo is already downloaded
     */
    setCustomTemplatesRootPathOrGitRepo(pathOrRepoUri, forceLoadingRemoteRepo = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (pathOrRepoUri === undefined) {
                this.customTemplatesRootPath = undefined;
                return;
            }
            try {
                // if pathOrRepoUri is valid url, load the repo
                const url = new URL(pathOrRepoUri);
                if (url) {
                    this.customTemplatesRootPath = yield (0, gitRepoUtils_1.loadCustomTemplatesGitRepo)(url, forceLoadingRemoteRepo);
                }
            }
            catch (error) {
                const err = error;
                if (err.code !== 'ERR_INVALID_URL') {
                    throw error;
                }
                const localTemplatesPath = pathOrRepoUri;
                if (fs.existsSync(localTemplatesPath)) {
                    this.customTemplatesRootPath = localTemplatesPath;
                }
                else {
                    throw new Error(i18n_1.nls.localize('localCustomTemplateDoNotExist', localTemplatesPath));
                }
            }
        });
    }
}
exports.TemplateService = TemplateService;
//# sourceMappingURL=templateService.js.map